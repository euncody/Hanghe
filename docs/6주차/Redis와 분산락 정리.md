# Redis와 분산락 정리

## 1. Redis란?
Redis는 **인메모리(in-memory) 데이터 저장소**예요.  
쉽게 말해, **RAM 위에 올려놓고 아주 빠르게 읽고 쓰는 데이터베이스**입니다.  

### 📌 핵심 특징
1. **인메모리 저장**  
   - 데이터가 메모리에 저장되기 때문에 읽기/쓰기 속도가 매우 빠름 (보통 마이크로초 단위).
   - 필요하면 디스크에 주기적으로 백업 가능.
   
2. **Key-Value 구조**  
   - `key`와 `value` 쌍으로 데이터 저장.  
   - value는 문자열뿐만 아니라 **리스트, 해시, 집합, 정렬된 집합, 비트맵 등** 다양한 자료구조를 지원.
   
3. **다양한 활용**  
   - **캐시**: 자주 쓰이는 데이터를 DB 대신 Redis에서 읽어 속도 향상.
   - **세션 저장소**: 로그인 정보 같은 세션 데이터 저장.
   - **실시간 랭킹**: 게임 점수판, 좋아요 순위 등.
   - **분산 락**: 여러 서버에서 동시에 처리할 때 충돌 방지.
   - **메시지 큐**: pub/sub(발행/구독) 기능으로 실시간 알림, 채팅 등 구현.
   
4. **싱글 스레드지만 빠름**  
   - 싱글 스레드 구조라 동시성 제어가 단순.
   - 메모리 기반 + 고효율 C 언어 구현 덕분에 처리량이 큼.

### 📂 간단한 예시
```bash
# Redis CLI 접속
redis-cli

# 데이터 저장
SET name "은스페어"

# 데이터 조회
GET name
# -> "은스페어"

# 리스트
LPUSH fruits "apple"
LPUSH fruits "banana"
LRANGE fruits 0 -1
# -> ["banana", "apple"]
```

📍 **정리:**  
Redis는 "빠른 데이터 임시 저장소"이자 "다양한 자료구조를 지원하는 키-값 데이터베이스"입니다.  
속도가 매우 빨라서 **캐시, 세션, 실시간 데이터 처리**에 많이 씁니다.  

---

## 2. Distributed Lock (분산락) 개념

### 1️⃣ "분산 시스템에서 서로 다른 서버 인스턴스에 대한 일관된 락"
- **상황 예시**  
  쇼핑몰 서버가 여러 대 있고(서버 A, B, C), 고객들이 동시에 같은 상품의 결제 요청을 보냅니다.  
  - 서버 A: "이 상품 결제 진행"  
  - 서버 B: "나도 결제 진행"  
  - 서버 C: "나도 결제 진행"  
  → 이러면 **재고 초과 판매(overselling)** 문제가 생김.

- **락(Lock)**  
  "이 상품 처리 중이니, 다른 사람은 잠깐 기다려!" 하는 장치.  
  보통 단일 서버에서는 `synchronized`나 DB 트랜잭션으로 해결 가능하지만,  
  **서버가 여러 대면(분산 환경) 이 방법으로는 서로 모르는 상태**라서 동시성 문제가 생김.

- 그래서 **분산락**이 필요합니다.  
  분산락은 여러 서버가 **하나의 공통된 잠금 시스템**을 이용하게 해서, 한 번에 한 서버만 작업하게 함.

### 2️⃣ "분산된 서버/클러스터 간에도 Lock 보장"
- 서버가 10대든 100대든, **락은 한 번에 한 서버만 획득 가능**해야 함.
- Redis 같은 중앙 저장소를 사용하면  
  서버들이 모두 Redis에 "나 이 키(lock) 잡을래" 요청을 보내고,  
  먼저 잡은 서버만 작업을 진행 → 나머지는 대기 or 실패 처리.

### 3️⃣ "key-value 기반의 원자성을 이용한 Redis"
- Redis는 **원자 연산(atomic operation)**을 제공 → 동시에 여러 요청이 들어와도 충돌 없이 처리 가능.
- 예: `SETNX`(SET if Not eXists)  
  ```bash
  SETNX lock:product:123 "locked"
  ```
  - 이미 존재하면 실패 → 다른 서버가 먼저 락을 잡았다는 뜻
  - 없으면 생성 → 내가 락 성공

- 이런 방식으로 DB까지 안 가고 **메모리에서 락 관리** → 매우 빠르고 DB 부하 감소.

### 4️⃣ 정리 그림
```
[서버 A]  → Redis ←  [서버 B]
           | lock:상품123
           ↓
        누가 먼저 락 잡나?
```
- 락 잡은 서버만 재고 차감 로직 실행
- 락 해제되면 다음 서버가 실행

💡 **결론:**  
"분산락"은 **여러 서버에서 동시에 같은 자원을 건드리지 못하게** 막는 장치고,  
Redis를 쓰면 **빠르고 가벼운 방식**으로 구현 가능해서 실무에서 많이 씁니다.  

---

## 3. 단일 서버 vs 분산 서버 동시성 제어
- **단일 서버** → `synchronized`, DB 트랜잭션으로 제어 가능
- **분산 서버** → 각 서버의 메모리는 공유되지 않으므로, 공통 저장소(예: Redis)를 이용해야 함

✅ 여러 서버(분산 환경)에서 동시성을 제어하려면 모든 서버가 같이 볼 수 있는 **공통의 락 저장소**가 필요함.

---

## 4. Redis를 활용한 분산락 구현 방식

### 4.1 Simple Lock
**"문이 잠겨 있으면 그냥 돌아간다"** 방식  

```kotlin
락 획득 여부 = redis 에서 key 로 확인
if (락 획득) {
    try {
        로직 실행
    } finally {
        lock 제거
    }
} else {
    throw Lock 획득 실패 예외
}
```
- 실패 시 아무 것도 안 하고 바로 종료
- 장점: 구현 간단, 빠름
- 단점: 경쟁 심하면 실패율 높음, 재시도 필요

---

### 4.2 Spin Lock
**"문이 잠겨 있으면 계속 문고리를 돌려본다"** 방식  

```kotlin
재시도 횟수 = 0
while (true) {
    락 획득 여부 = redis 에서 key 로 확인 // SETNX key "1"
    if (락 획득) {
        try {
            로직 실행
        } finally {
            lock 제거
        }
        break;
    } else {
        재시도 횟수++
        if (재시도 횟수 == 최대 횟수) throw Lock 획득 실패 예외
        시간 지연 (대기)
    }
}
```
- 락 실패 시 일정 시간 대기 후 재시도
- 장점: 실패율 낮춤
- 단점: Redis 부하 증가, 스레드 점유 가능

---

### 4.3 Pub/Sub Lock
**"문이 열리면 문지기가 알려준다"** 방식  

```kotlin
락 획득 여부 = redis 에서 lock 데이터 에 대한 subscribe 요청 및 획득 시 값 반환
if (락 획득) {
    로직 실행
} else {
    throw Lock 획득 실패 예외
}
```
- 실패 시 "락 풀리면 알려줘" 하고 기다림
- 장점: 불필요한 반복 요청 없이 효율적
- 단점: 구현 복잡, 라이브러리별 차이 존재

---

## 5. 방식 비교
| 방식         | 비유                                  | 특징 |
|--------------|---------------------------------------|------|
| Simple Lock  | 문 잠겨 있으면 그냥 집에 돌아감        | 빠르지만 실패율 높음 |
| Spin Lock    | 문 잠겨 있으면 계속 문고리 돌려봄      | 성공률 높지만 네트워크/CPU 부하 |
| Pub/Sub Lock | 문 잠기면 문지기에게 "열리면 알려줘"   | 효율적이지만 구현 복잡 |
